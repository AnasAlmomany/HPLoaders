//
//  HPCircleKit.swift
//
//  Created on Feb 23, 2018.
//
//  Generated by PaintCode Plugin for Sketch
//  http://www.paintcodeapp.com/sketch
//

import UIKit

class HPCircleKit: NSObject {
	
	
	//MARK: - Canvas Drawings
	
	/// Page 1
	
	class func drawCircle4(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), resizing: ResizingBehavior = .aspectFit) {
		/// General Declarations
		let context = UIGraphicsGetCurrentContext()!
		/// Resize to Target Frame
		context.saveGState()
		let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 200, height: 200), target: targetFrame)
		context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
		context.scaleBy(x: resizedFrame.width / 200, y: resizedFrame.height / 200)
		
		/// Oval
		let oval5 = UIBezierPath()
		oval5.move(to: CGPoint(x: 58.2, y: 58.2))
		oval5.addCurve(to: CGPoint.zero, controlPoint1: CGPoint(x: 58.2, y: 26.06), controlPoint2: CGPoint(x: 32.14, y: 0))
		context.saveGState()
		context.translateBy(x: 100, y: 41.8)
		oval5.lineCapStyle = .round
		oval5.lineWidth = 6
		UIColor.white.setStroke()
		oval5.stroke()
		context.restoreGState()
		
		context.restoreGState()
	}
	
	class func drawCircle3(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), resizing: ResizingBehavior = .aspectFit) {
		/// General Declarations
		let context = UIGraphicsGetCurrentContext()!
		
		/// Resize to Target Frame
		context.saveGState()
		let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 200, height: 200), target: targetFrame)
		context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
		context.scaleBy(x: resizedFrame.width / 200, y: resizedFrame.height / 200)
		
		/// Oval
		let oval4 = UIBezierPath()
		oval4.move(to: CGPoint(x: 67.9, y: 67.9))
		oval4.addCurve(to: CGPoint.zero, controlPoint1: CGPoint(x: 67.9, y: 30.4), controlPoint2: CGPoint(x: 37.5, y: 0))
		context.saveGState()
		context.translateBy(x: 100, y: 32.1)
		oval4.lineCapStyle = .round
		oval4.lineWidth = 6
		UIColor.white.setStroke()
		oval4.stroke()
		context.restoreGState()
		
		context.restoreGState()
	}
	
	class func drawCircle2(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), resizing: ResizingBehavior = .aspectFit) {
		/// General Declarations
		let context = UIGraphicsGetCurrentContext()!
		
		/// Resize to Target Frame
		context.saveGState()
		let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 200, height: 200), target: targetFrame)
		context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
		context.scaleBy(x: resizedFrame.width / 200, y: resizedFrame.height / 200)
		
		/// Oval
		let oval3 = UIBezierPath()
		oval3.move(to: CGPoint(x: 77.6, y: 77.6))
		oval3.addCurve(to: CGPoint.zero, controlPoint1: CGPoint(x: 77.6, y: 34.74), controlPoint2: CGPoint(x: 42.86, y: 0))
		context.saveGState()
		context.translateBy(x: 100, y: 22.4)
		oval3.lineCapStyle = .round
		oval3.lineWidth = 6
		UIColor.white.setStroke()
		oval3.stroke()
		context.restoreGState()
		
		context.restoreGState()
	}
	
	class func drawCircle1(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), resizing: ResizingBehavior = .aspectFit) {
		/// General Declarations
		let context = UIGraphicsGetCurrentContext()!
		
		/// Resize to Target Frame
		context.saveGState()
		let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 200, height: 200), target: targetFrame)
		context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
		context.scaleBy(x: resizedFrame.width / 200, y: resizedFrame.height / 200)
		
		/// Oval
		let oval2 = UIBezierPath()
		oval2.move(to: CGPoint(x: 87.3, y: 87.3))
		oval2.addCurve(to: CGPoint.zero, controlPoint1: CGPoint(x: 87.3, y: 39.09), controlPoint2: CGPoint(x: 48.21, y: 0))
		context.saveGState()
		context.translateBy(x: 100, y: 12.7)
		oval2.lineCapStyle = .round
		oval2.lineWidth = 6
		UIColor.white.setStroke()
		oval2.stroke()
		context.restoreGState()
		
		context.restoreGState()
	}
	
	class func drawCircle0(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), resizing: ResizingBehavior = .aspectFit) {
		/// General Declarations
		let context = UIGraphicsGetCurrentContext()!
		
		/// Resize to Target Frame
		context.saveGState()
		let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 200, height: 200), target: targetFrame)
		context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
		context.scaleBy(x: resizedFrame.width / 200, y: resizedFrame.height / 200)
		
		/// Oval
		let oval = UIBezierPath()
		oval.move(to: CGPoint(x: 97, y: 97))
		oval.addCurve(to: CGPoint.zero, controlPoint1: CGPoint(x: 97, y: 43.43), controlPoint2: CGPoint(x: 53.57, y: 0))
		context.saveGState()
		context.translateBy(x: 100, y: 3)
		oval.lineCapStyle = .round
		oval.lineWidth = 6
		UIColor.white.setStroke()
		oval.stroke()
		context.restoreGState()
		
		context.restoreGState()
	}
	
	
	//MARK: - Canvas Images
	
	/// Page 1
	
	class func imageOfCircle4() -> UIImage {
		struct LocalCache {
			static var image: UIImage!
		}
		if LocalCache.image != nil {
			return LocalCache.image
		}
		var image: UIImage
		
		UIGraphicsBeginImageContextWithOptions(CGSize(width: 200, height: 200), false, 0)
		HPCircleKit.drawCircle4()
		image = UIGraphicsGetImageFromCurrentImageContext()!
		UIGraphicsEndImageContext()
		
		LocalCache.image = image
		return image
	}
	
	class func imageOfCircle3() -> UIImage {
		struct LocalCache {
			static var image: UIImage!
		}
		if LocalCache.image != nil {
			return LocalCache.image
		}
		var image: UIImage
		
		UIGraphicsBeginImageContextWithOptions(CGSize(width: 200, height: 200), false, 0)
		HPCircleKit.drawCircle3()
		image = UIGraphicsGetImageFromCurrentImageContext()!
		UIGraphicsEndImageContext()
		
		LocalCache.image = image
		return image
	}
	
	class func imageOfCircle2() -> UIImage {
		struct LocalCache {
			static var image: UIImage!
		}
		if LocalCache.image != nil {
			return LocalCache.image
		}
		var image: UIImage
		
		UIGraphicsBeginImageContextWithOptions(CGSize(width: 200, height: 200), false, 0)
		HPCircleKit.drawCircle2()
		image = UIGraphicsGetImageFromCurrentImageContext()!
		UIGraphicsEndImageContext()
		
		LocalCache.image = image
		return image
	}
	
	class func imageOfCircle1() -> UIImage {
		struct LocalCache {
			static var image: UIImage!
		}
		if LocalCache.image != nil {
			return LocalCache.image
		}
		var image: UIImage
		
		UIGraphicsBeginImageContextWithOptions(CGSize(width: 200, height: 200), false, 0)
		HPCircleKit.drawCircle1()
		image = UIGraphicsGetImageFromCurrentImageContext()!
		UIGraphicsEndImageContext()
		
		LocalCache.image = image
		return image
	}
	
	class func imageOfCircle0() -> UIImage {
		struct LocalCache {
			static var image: UIImage!
		}
		if LocalCache.image != nil {
			return LocalCache.image
		}
		var image: UIImage
		
		UIGraphicsBeginImageContextWithOptions(CGSize(width: 200, height: 200), false, 0)
		HPCircleKit.drawCircle0()
		image = UIGraphicsGetImageFromCurrentImageContext()!
		UIGraphicsEndImageContext()
		
		LocalCache.image = image
		return image
	}
	
	
	//MARK: - Resizing Behavior
	
	enum ResizingBehavior {
		case aspectFit /// The content is proportionally resized to fit into the target rectangle.
		case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
		case stretch /// The content is stretched to match the entire target rectangle.
		case center /// The content is centered in the target rectangle, but it is NOT resized.
		
		func apply(rect: CGRect, target: CGRect) -> CGRect {
			if rect == target || target == CGRect.zero {
				return rect
			}
			
			var scales = CGSize.zero
			scales.width = abs(target.width / rect.width)
			scales.height = abs(target.height / rect.height)
			
			switch self {
				case .aspectFit:
					scales.width = min(scales.width, scales.height)
					scales.height = scales.width
				case .aspectFill:
					scales.width = max(scales.width, scales.height)
					scales.height = scales.width
				case .stretch:
					break
				case .center:
					scales.width = 1
					scales.height = 1
			}
			
			var result = rect.standardized
			result.size.width *= scales.width
			result.size.height *= scales.height
			result.origin.x = target.minX + (target.width - result.width) / 2
			result.origin.y = target.minY + (target.height - result.height) / 2
			return result
		}
	}
	
	
}
